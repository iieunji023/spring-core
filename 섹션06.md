## 웹 애플리케이션과 싱글톤

- 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.
- 대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 물론 웹이 아닌 애플리케이션 개발도 얼마든지 개발할 수 있다
- 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다
- 웹 애플리케이션은 계속해서 고객의 요청이 들어오는 곳
- 클라이언트의 요청이 있을 때마다 객체가 생성된다면..?

<img src="https://github.com/iieunji023/spring-core/blob/main/images/스프링없는DI컨테이너.png" width="730">

### 테스트 코드 작성

> 스프링 없는 순수한 DI 컨테이너 테스트
SingletonTest.java
- 테스트를 진행할 때는 자동화되게 만들어야 함
    - sout으로 출력 X
    - `Assertions.assertThat(memberService1).isNotSameAs(memberService2);`처럼 자동화되게끔 작성하기

      <img src="https://github.com/iieunji023/spring-core/blob/main/images/스프링없는DI컨테이너_테스트결과.png" width="730">
      
      - 요청을 보낼 때마다 다른 객체가 생성됨

## 싱글톤 패턴

- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다
    - private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다

### 텍스트 코드 작성

> 싱글톤을 구성한 Service 클래스 만들기 - SingletonService.java

- `private static final SingletonService instance = new SingletonService();`
    - 클래스 레벨에 올라가기 때문에 딱 하나만 존재함
- `private SingletonService() {}` → private으로 만든 이유
    - 외부에서 new SingletonService(); 생성을 막기 위함
    - 싱글톤 생성자를 계속 생성하면 싱글톤을 쓰는 의미가 없기 때문

```
💡 정리
1. static 영역에 객체 instance를 미리 하나 생성해서 올려둔다
2. 이 객체 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회할 수 있다.
이 메서드를 호출하면 항상 같은 인스턴스를 반환한다
3. 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다
```

> 객체를 하나만 생성하는지 확인하기 위한 테스트 - SingletonTest.java
- private으로 new 키워드를 막아둠
- isSameAs를 쓴 이유
    - 인스턴스를 비교하기 위함
```
💡 isSameAs vs isEqualTo
- isEqualTo
    - equals()
- isSameAs
    - ==
```

<img src="https://github.com/iieunji023/spring-core/blob/main/images/싱글톤패턴_테스트결과.png" width="730">

- 호출할 때마다 같은 객체 인스턴스를 반환하는 것을 확인할 수 있음

💡 싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 하지만 싱글톤 패턴은 다음과 같은 수 많은 문제점들을 가지고 있다.

### 싱글톤 패턴 문제점

- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다
    ```
          
  ```  

    <details>
      <summary>코드</summary>
  
        package hello.core.singleton;
        
          public class SingletonService {
              private static final SingletonService instance = new SingletonService();    // 클래스 레벨에 올라가기 때문에 딱 하나만 존재함
        
              public static SingletonService getInstance() {
                  return instance;
              }
        
              // 외부에서 new SingletonService(); 생성을 막기 위해
              // 싱글톤 생성자를 계속 생성하면 싱글톤을 쓰는 의미가 없기 때문
              private SingletonService() {
                
              }
            
              public void logic() {
                  System.out.println("싱글톤 객체 로직 호출");
              }
        
          }

    - `logic()` 메서드 한줄을 위해 6-7줄의 코드 필요

    </details>

- 의존관계상 클라이언트가 구체 클래스에 의존한다(`getInstance()` 메서드에 의존)
    - DIP 위반
- 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다
- 테스트하기 어렵다
- 내부 속성을 변경하거나 초기화하기 어렵다
- private 생성자로 자식 클래스를 만들기 어렵다
- 결론적으로 유연성이 떨어진다
- 안티패턴으로 불리기도 한다